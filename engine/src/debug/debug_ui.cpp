#include "engine/debug/debug_ui.h"
#include "engine/core/log.h"

#include <glad/glad.h>
#include <cstdarg>
#include <cstring>

namespace Engine {

std::vector<DebugUI::TextEntry> DebugUI::s_TextQueue;
u32 DebugUI::s_FontTexture = 0;
u32 DebugUI::s_VAO = 0;
u32 DebugUI::s_VBO = 0;
Ref<Shader> DebugUI::s_Shader = nullptr;
bool DebugUI::s_Enabled = true;

// 简易 8x14 ASCII 位图字体 (空格到~)
// 这里使用程序化生成的点阵——每个字符用一系列点来表示可辨认的形状
static const char* uiVert = R"(
#version 450 core
layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aTexCoord;
out vec2 vUV;
uniform mat4 uProj;
void main() {
    vUV = aTexCoord;
    gl_Position = uProj * vec4(aPos, 0.0, 1.0);
}
)";

static const char* uiFrag = R"(
#version 450 core
in vec2 vUV;
out vec4 FragColor;
uniform sampler2D uFont;
uniform vec3 uColor;
void main() {
    float a = texture(uFont, vUV).r;
    if (a < 0.5) discard;
    FragColor = vec4(uColor, a);
}
)";

// ── 简易点阵字体生成 ────────────────────────────────────────
// 仅覆盖 ASCII 32-126，每个字符 8x14 像素点阵
// 这里用一个简单的 5x7 核心字形居中放置在 8x14 格子中

// 5x7 位图字体数据(经典 IBM PC 风格)，每个字符 7 字节(每字节代表一行，5bit 宽)
static const unsigned char font5x7[][7] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 32 space
    {0x04,0x04,0x04,0x04,0x04,0x00,0x04}, // 33 !
    {0x0A,0x0A,0x00,0x00,0x00,0x00,0x00}, // 34 "
    {0x0A,0x1F,0x0A,0x0A,0x1F,0x0A,0x00}, // 35 #
    {0x04,0x0F,0x14,0x0E,0x05,0x1E,0x04}, // 36 $
    {0x19,0x19,0x02,0x04,0x08,0x13,0x13}, // 37 %
    {0x06,0x09,0x06,0x16,0x09,0x09,0x16}, // 38 &
    {0x04,0x04,0x00,0x00,0x00,0x00,0x00}, // 39 '
    {0x02,0x04,0x08,0x08,0x08,0x04,0x02}, // 40 (
    {0x08,0x04,0x02,0x02,0x02,0x04,0x08}, // 41 )
    {0x00,0x04,0x15,0x0E,0x15,0x04,0x00}, // 42 *
    {0x00,0x04,0x04,0x1F,0x04,0x04,0x00}, // 43 +
    {0x00,0x00,0x00,0x00,0x00,0x04,0x08}, // 44 ,
    {0x00,0x00,0x00,0x1F,0x00,0x00,0x00}, // 45 -
    {0x00,0x00,0x00,0x00,0x00,0x00,0x04}, // 46 .
    {0x01,0x01,0x02,0x04,0x08,0x10,0x10}, // 47 /
    {0x0E,0x11,0x13,0x15,0x19,0x11,0x0E}, // 48 0
    {0x04,0x0C,0x04,0x04,0x04,0x04,0x0E}, // 49 1
    {0x0E,0x11,0x01,0x06,0x08,0x10,0x1F}, // 50 2
    {0x0E,0x11,0x01,0x06,0x01,0x11,0x0E}, // 51 3
    {0x02,0x06,0x0A,0x12,0x1F,0x02,0x02}, // 52 4
    {0x1F,0x10,0x1E,0x01,0x01,0x11,0x0E}, // 53 5
    {0x06,0x08,0x10,0x1E,0x11,0x11,0x0E}, // 54 6
    {0x1F,0x01,0x02,0x04,0x08,0x08,0x08}, // 55 7
    {0x0E,0x11,0x11,0x0E,0x11,0x11,0x0E}, // 56 8
    {0x0E,0x11,0x11,0x0F,0x01,0x02,0x0C}, // 57 9
    {0x00,0x00,0x04,0x00,0x00,0x04,0x00}, // 58 :
    {0x00,0x00,0x04,0x00,0x00,0x04,0x08}, // 59 ;
    {0x02,0x04,0x08,0x10,0x08,0x04,0x02}, // 60 <
    {0x00,0x00,0x1F,0x00,0x1F,0x00,0x00}, // 61 =
    {0x08,0x04,0x02,0x01,0x02,0x04,0x08}, // 62 >
    {0x0E,0x11,0x01,0x02,0x04,0x00,0x04}, // 63 ?
    {0x0E,0x11,0x17,0x15,0x17,0x10,0x0E}, // 64 @
    {0x04,0x0A,0x11,0x11,0x1F,0x11,0x11}, // 65 A
    {0x1E,0x11,0x11,0x1E,0x11,0x11,0x1E}, // 66 B
    {0x0E,0x11,0x10,0x10,0x10,0x11,0x0E}, // 67 C
    {0x1E,0x11,0x11,0x11,0x11,0x11,0x1E}, // 68 D
    {0x1F,0x10,0x10,0x1E,0x10,0x10,0x1F}, // 69 E
    {0x1F,0x10,0x10,0x1E,0x10,0x10,0x10}, // 70 F
    {0x0E,0x11,0x10,0x17,0x11,0x11,0x0F}, // 71 G
    {0x11,0x11,0x11,0x1F,0x11,0x11,0x11}, // 72 H
    {0x0E,0x04,0x04,0x04,0x04,0x04,0x0E}, // 73 I
    {0x07,0x02,0x02,0x02,0x02,0x12,0x0C}, // 74 J
    {0x11,0x12,0x14,0x18,0x14,0x12,0x11}, // 75 K
    {0x10,0x10,0x10,0x10,0x10,0x10,0x1F}, // 76 L
    {0x11,0x1B,0x15,0x15,0x11,0x11,0x11}, // 77 M
    {0x11,0x19,0x15,0x13,0x11,0x11,0x11}, // 78 N
    {0x0E,0x11,0x11,0x11,0x11,0x11,0x0E}, // 79 O
    {0x1E,0x11,0x11,0x1E,0x10,0x10,0x10}, // 80 P
    {0x0E,0x11,0x11,0x11,0x15,0x12,0x0D}, // 81 Q
    {0x1E,0x11,0x11,0x1E,0x14,0x12,0x11}, // 82 R
    {0x0E,0x11,0x10,0x0E,0x01,0x11,0x0E}, // 83 S
    {0x1F,0x04,0x04,0x04,0x04,0x04,0x04}, // 84 T
    {0x11,0x11,0x11,0x11,0x11,0x11,0x0E}, // 85 U
    {0x11,0x11,0x11,0x11,0x11,0x0A,0x04}, // 86 V
    {0x11,0x11,0x11,0x15,0x15,0x15,0x0A}, // 87 W
    {0x11,0x11,0x0A,0x04,0x0A,0x11,0x11}, // 88 X
    {0x11,0x11,0x0A,0x04,0x04,0x04,0x04}, // 89 Y
    {0x1F,0x01,0x02,0x04,0x08,0x10,0x1F}, // 90 Z
    {0x0E,0x08,0x08,0x08,0x08,0x08,0x0E}, // 91 [
    {0x10,0x10,0x08,0x04,0x02,0x01,0x01}, // 92 backslash
    {0x0E,0x02,0x02,0x02,0x02,0x02,0x0E}, // 93 ]
    {0x04,0x0A,0x11,0x00,0x00,0x00,0x00}, // 94 ^
    {0x00,0x00,0x00,0x00,0x00,0x00,0x1F}, // 95 _
    {0x08,0x04,0x00,0x00,0x00,0x00,0x00}, // 96 `
    {0x00,0x00,0x0E,0x01,0x0F,0x11,0x0F}, // 97 a
    {0x10,0x10,0x1E,0x11,0x11,0x11,0x1E}, // 98 b
    {0x00,0x00,0x0E,0x11,0x10,0x11,0x0E}, // 99 c
    {0x01,0x01,0x0F,0x11,0x11,0x11,0x0F}, // 100 d
    {0x00,0x00,0x0E,0x11,0x1F,0x10,0x0E}, // 101 e
    {0x06,0x09,0x08,0x1C,0x08,0x08,0x08}, // 102 f
    {0x00,0x00,0x0F,0x11,0x0F,0x01,0x0E}, // 103 g
    {0x10,0x10,0x16,0x19,0x11,0x11,0x11}, // 104 h
    {0x04,0x00,0x0C,0x04,0x04,0x04,0x0E}, // 105 i
    {0x02,0x00,0x06,0x02,0x02,0x12,0x0C}, // 106 j
    {0x10,0x10,0x12,0x14,0x18,0x14,0x12}, // 107 k
    {0x0C,0x04,0x04,0x04,0x04,0x04,0x0E}, // 108 l
    {0x00,0x00,0x1A,0x15,0x15,0x11,0x11}, // 109 m
    {0x00,0x00,0x16,0x19,0x11,0x11,0x11}, // 110 n
    {0x00,0x00,0x0E,0x11,0x11,0x11,0x0E}, // 111 o
    {0x00,0x00,0x1E,0x11,0x1E,0x10,0x10}, // 112 p
    {0x00,0x00,0x0F,0x11,0x0F,0x01,0x01}, // 113 q
    {0x00,0x00,0x16,0x19,0x10,0x10,0x10}, // 114 r
    {0x00,0x00,0x0E,0x10,0x0E,0x01,0x1E}, // 115 s
    {0x08,0x08,0x1C,0x08,0x08,0x09,0x06}, // 116 t
    {0x00,0x00,0x11,0x11,0x11,0x13,0x0D}, // 117 u
    {0x00,0x00,0x11,0x11,0x11,0x0A,0x04}, // 118 v
    {0x00,0x00,0x11,0x11,0x15,0x15,0x0A}, // 119 w
    {0x00,0x00,0x11,0x0A,0x04,0x0A,0x11}, // 120 x
    {0x00,0x00,0x11,0x11,0x0F,0x01,0x0E}, // 121 y
    {0x00,0x00,0x1F,0x02,0x04,0x08,0x1F}, // 122 z
    {0x02,0x04,0x04,0x08,0x04,0x04,0x02}, // 123 {
    {0x04,0x04,0x04,0x04,0x04,0x04,0x04}, // 124 |
    {0x08,0x04,0x04,0x02,0x04,0x04,0x08}, // 125 }
    {0x00,0x00,0x00,0x16,0x09,0x00,0x00}, // 126 ~
};

void DebugUI::BuildFontTexture() {
    const u32 texW = COLS * CHAR_W;  // 128
    const u32 texH = ROWS * CHAR_H; // 84
    std::vector<unsigned char> pixels(texW * texH, 0);

    for (int ch = 32; ch <= 126; ch++) {
        int idx = ch - 32;
        int col = idx % COLS;
        int row = idx / COLS;
        int baseX = col * CHAR_W;
        int baseY = row * CHAR_H;

        // 居中: 5x7 字形放在 8x14 格子中央
        int offX = (CHAR_W - 5) / 2;   // 1
        int offY = (CHAR_H - 7) / 2;   // 3

        for (int r = 0; r < 7; r++) {
            unsigned char bits = font5x7[idx][r];
            for (int c = 0; c < 5; c++) {
                if (bits & (0x10 >> c)) { // MSB first
                    int px = baseX + offX + c;
                    int py = baseY + offY + r;
                    if (px < (int)texW && py < (int)texH)
                        pixels[py * texW + px] = 255;
                }
            }
        }
    }

    glGenTextures(1, &s_FontTexture);
    glBindTexture(GL_TEXTURE_2D, s_FontTexture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, texW, texH, 0, GL_RED, GL_UNSIGNED_BYTE, pixels.data());
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
}

void DebugUI::Init() {
    BuildFontTexture();

    glGenVertexArrays(1, &s_VAO);
    glGenBuffers(1, &s_VBO);
    glBindVertexArray(s_VAO);
    glBindBuffer(GL_ARRAY_BUFFER, s_VBO);
    // 预分配足够的空间 (每个字符 6 顶点 * 4 floats)
    glBufferData(GL_ARRAY_BUFFER, 4096 * 6 * 4 * sizeof(float), nullptr, GL_DYNAMIC_DRAW);
    // position (2 floats)
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4*sizeof(float), (void*)0);
    // texcoord (2 floats)
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4*sizeof(float), (void*)(2*sizeof(float)));
    glBindVertexArray(0);

    s_Shader = std::make_shared<Shader>(uiVert, uiFrag);
    LOG_INFO("[调试UI] 初始化完成 (位图字体 128x84)");
}

void DebugUI::Shutdown() {
    if (s_FontTexture) { glDeleteTextures(1, &s_FontTexture); s_FontTexture = 0; }
    if (s_VAO) { glDeleteVertexArrays(1, &s_VAO); s_VAO = 0; }
    if (s_VBO) { glDeleteBuffers(1, &s_VBO); s_VBO = 0; }
    s_Shader.reset();
    s_TextQueue.clear();
}

void DebugUI::Text(f32 x, f32 y, const std::string& text,
                   const glm::vec3& color, f32 scale) {
    if (!s_Enabled) return;
    s_TextQueue.push_back({x, y, text, color, scale});
}

void DebugUI::Printf(f32 x, f32 y, const glm::vec3& color, const char* fmt, ...) {
    if (!s_Enabled) return;
    char buf[512];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    Text(x, y, buf, color);
}

void DebugUI::DrawStatsPanel(f32 fps, u32 drawCalls, u32 triangles, u32 particles,
                              u32 entities, u32 debugLines, f32 exposure, f32 fov) {
    f32 x = 10, y = 10;
    f32 lineH = CHAR_H + 2;
    glm::vec3 cTitle = {1.0f, 0.8f, 0.2f};
    glm::vec3 cValue = {0.8f, 0.9f, 1.0f};
    glm::vec3 cGood  = {0.3f, 1.0f, 0.4f};
    glm::vec3 cWarn  = {1.0f, 0.5f, 0.2f};

    Printf(x, y, cTitle, "=== Debug Panel ==="); y += lineH;
    Printf(x, y, fps >= 55 ? cGood : cWarn, "FPS:       %.1f", fps); y += lineH;
    Printf(x, y, cValue, "Draw Calls: %u", drawCalls); y += lineH;
    Printf(x, y, cValue, "Triangles:  %u", triangles); y += lineH;
    Printf(x, y, cValue, "Particles:  %u", particles); y += lineH;
    Printf(x, y, cValue, "Entities:   %u", entities); y += lineH;
    Printf(x, y, cValue, "Debug Lines:%u", debugLines); y += lineH;
    Printf(x, y, cValue, "Exposure:   %.2f", exposure); y += lineH;
    Printf(x, y, cValue, "FOV:        %.1f", fov); y += lineH;
}

void DebugUI::Flush(u32 screenWidth, u32 screenHeight) {
    if (!s_Enabled || s_TextQueue.empty()) {
        s_TextQueue.clear();
        return;
    }

    // 构建顶点数据（静态 vector 避免每帧分配）
    static std::vector<float> verts;
    verts.reserve(s_TextQueue.size() * 20 * 6 * 4); // 估算
    static constexpr size_t MAX_VBO_FLOATS = 4096 * 6 * 4; // 与 Init 中预分配一致

    const f32 uvW = (f32)CHAR_W / (f32)(COLS * CHAR_W);  // 1 字符在图集中的 UV 宽
    const f32 uvH = (f32)CHAR_H / (f32)(ROWS * CHAR_H);  // 1 字符在图集中的 UV 高

    // 按颜色批处理
    // 保存当前 GL 状态
    GLint prevDepthTest, prevBlend;
    glGetIntegerv(GL_DEPTH_TEST, &prevDepthTest);
    glGetIntegerv(GL_BLEND, &prevBlend);

    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    s_Shader->Bind();
    // 正交投影 (左上角原点)
    float proj[16] = {
        2.0f/(float)screenWidth, 0, 0, 0,
        0, -2.0f/(float)screenHeight, 0, 0,
        0, 0, -1, 0,
        -1, 1, 0, 1
    };
    s_Shader->SetMat4("uProj", proj);
    s_Shader->SetInt("uFont", 0);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, s_FontTexture);

    for (auto& entry : s_TextQueue) {
        verts.clear();
        f32 curX = entry.X;
        f32 curY = entry.Y;
        f32 charW = CHAR_W * entry.Scale;
        f32 charH = CHAR_H * entry.Scale;

        for (char ch : entry.Content) {
            if (ch == '\n') { curX = entry.X; curY += charH + 2; continue; }
            if (ch < 32 || ch > 126) ch = '?';

            int idx = ch - 32;
            int col = idx % COLS;
            int row = idx / COLS;
            f32 u0 = col * uvW;
            f32 v0 = row * uvH;
            f32 u1 = u0 + uvW;
            f32 v1 = v0 + uvH;

            // 两个三角形 (6 顶点)
            f32 x0 = curX, y0 = curY;
            f32 x1 = curX + charW, y1 = curY + charH;

            verts.insert(verts.end(), {x0,y0, u0,v0});
            verts.insert(verts.end(), {x1,y0, u1,v0});
            verts.insert(verts.end(), {x1,y1, u1,v1});
            verts.insert(verts.end(), {x0,y0, u0,v0});
            verts.insert(verts.end(), {x1,y1, u1,v1});
            verts.insert(verts.end(), {x0,y1, u0,v1});

            curX += charW;
        }

        if (verts.empty()) continue;

        // 缓冲区溢出保护
        if (verts.size() > MAX_VBO_FLOATS) {
            LOG_WARN("[调试UI] 文本顶点超出 VBO 容量，截断渲染");
            verts.resize(MAX_VBO_FLOATS);
        }

        s_Shader->SetVec3("uColor", entry.Color.x, entry.Color.y, entry.Color.z);
        glBindVertexArray(s_VAO);
        glBindBuffer(GL_ARRAY_BUFFER, s_VBO);
        glBufferSubData(GL_ARRAY_BUFFER, 0, (GLsizeiptr)(verts.size()*sizeof(float)), verts.data());
        glDrawArrays(GL_TRIANGLES, 0, (GLsizei)(verts.size() / 4));
    }

    glBindVertexArray(0);

    // 恢复 GL 状态
    if (prevDepthTest) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
    if (!prevBlend) glDisable(GL_BLEND);

    s_TextQueue.clear();
}

void DebugUI::SetEnabled(bool enabled) { s_Enabled = enabled; }
bool DebugUI::IsEnabled() { return s_Enabled; }

} // namespace Engine
